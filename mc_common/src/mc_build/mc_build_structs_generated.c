// Copyright (c) 2012-2019 Matt Campbell
// MIT license (see License.txt)

// AUTOGENERATED FILE - DO NOT EDIT

// clang-format off

#include "mc_build/mc_build_structs_generated.h"
#include "bb_array.h"
#include "str.h"
#include "va.h"

#include "mc_build/mc_build_commands.h"
#include "mc_build/mc_build_dependencies.h"
#include "sb.h"
#include "sdict.h"
#include "uuid_rfc4122/sysdep.h"

#include <string.h>


void buildCommand_reset_from_loc(const char *file, int line, buildCommand_t *val)
{
	if(val) {
		sb_reset_from_loc(file, line, &val->title);
		sb_reset_from_loc(file, line, &val->dir);
		sb_reset_from_loc(file, line, &val->command);
		sb_reset_from_loc(file, line, &val->stdoutBuffer);
		sb_reset_from_loc(file, line, &val->stderrBuffer);
	}
}
buildCommand_t buildCommand_clone_from_loc(const char *file, int line, const buildCommand_t *src)
{
	buildCommand_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.title = sb_clone_from_loc(file, line, &src->title);
		dst.dir = sb_clone_from_loc(file, line, &src->dir);
		dst.command = sb_clone_from_loc(file, line, &src->command);
		dst.stdoutBuffer = sb_clone_from_loc(file, line, &src->stdoutBuffer);
		dst.stderrBuffer = sb_clone_from_loc(file, line, &src->stderrBuffer);
		dst.result = src->result;
		dst.bDispatched = src->bDispatched;
		dst.bFinished = src->bFinished;
		dst.bTitlePrinted = src->bTitlePrinted;
		dst.bResultPrinted = src->bResultPrinted;
	}
	return dst;
}

void buildCommands_reset_from_loc(const char *file, int line, buildCommands_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			buildCommand_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
buildCommands_t buildCommands_clone_from_loc(const char *file, int line, const buildCommands_t *src)
{
	buildCommands_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = buildCommand_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void sourceTimestampEntry_reset_from_loc(const char *file, int line, sourceTimestampEntry *val)
{
	if(val) {
		sb_reset_from_loc(file, line, &val->key);
	}
}
sourceTimestampEntry sourceTimestampEntry_clone_from_loc(const char *file, int line, const sourceTimestampEntry *src)
{
	sourceTimestampEntry dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.key = sb_clone_from_loc(file, line, &src->key);
		dst.timestamp = src->timestamp;
	}
	return dst;
}

void sourceTimestampChain_reset_from_loc(const char *file, int line, sourceTimestampChain *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			sourceTimestampEntry_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
sourceTimestampChain sourceTimestampChain_clone_from_loc(const char *file, int line, const sourceTimestampChain *src)
{
	sourceTimestampChain dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = sourceTimestampEntry_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void sourceTimestampTable_reset_from_loc(const char *file, int line, sourceTimestampTable *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			sourceTimestampChain_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
sourceTimestampTable sourceTimestampTable_clone_from_loc(const char *file, int line, const sourceTimestampTable *src)
{
	sourceTimestampTable dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = sourceTimestampChain_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void buildDependencyEntry_reset_from_loc(const char *file, int line, buildDependencyEntry *val)
{
	if(val) {
		sb_reset_from_loc(file, line, &val->key);
		sbs_reset_from_loc(file, line, &val->deps);
	}
}
buildDependencyEntry buildDependencyEntry_clone_from_loc(const char *file, int line, const buildDependencyEntry *src)
{
	buildDependencyEntry dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.key = sb_clone_from_loc(file, line, &src->key);
		dst.deps = sbs_clone_from_loc(file, line, &src->deps);
	}
	return dst;
}

void buildDependencyChain_reset_from_loc(const char *file, int line, buildDependencyChain *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			buildDependencyEntry_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
buildDependencyChain buildDependencyChain_clone_from_loc(const char *file, int line, const buildDependencyChain *src)
{
	buildDependencyChain dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = buildDependencyEntry_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void buildDependencyTable_reset_from_loc(const char *file, int line, buildDependencyTable *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			buildDependencyChain_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
buildDependencyTable buildDependencyTable_clone_from_loc(const char *file, int line, const buildDependencyTable *src)
{
	buildDependencyTable dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = buildDependencyChain_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

u64 sourceTimestampEntry_hash(const sourceTimestampEntry *entry)
{
	return strsimplehash(sb_get(&entry->key));
}

int sourceTimestampEntry_compare(const sourceTimestampEntry *a, const sourceTimestampEntry *b)
{
	return strcmp(sb_get(&a->key), sb_get(&b->key));
}

sourceTimestampEntry *sourceTimestampTable_find_internal(sourceTimestampTable *table, const sourceTimestampEntry *entry, u64 hashValue)
{
	BB_ASSERT_MSG(table->count, "need to initialize hash table count");
	u32 chainIndex = hashValue % table->count;
	sourceTimestampChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count; ++i) {
		sourceTimestampEntry *existing = chain->data + i;
		if(!sourceTimestampEntry_compare(existing, entry)) {
			return existing;
		}
	}
	return NULL;
}

sourceTimestampEntry *sourceTimestampTable_insert_internal(sourceTimestampTable *table, const sourceTimestampEntry *entry, u64 hashValue)
{
	BB_ASSERT_MSG(table->count, "need to initialize hash table count");
	sourceTimestampEntry *result = sourceTimestampTable_find_internal(table, entry, hashValue);
	if(!result) {
		u32 chainIndex = hashValue % table->count;
		sourceTimestampChain *chain = table->data + chainIndex;
		result = bba_add_noclear(*chain, 1);
		if(result != NULL) {
			*result = sourceTimestampEntry_clone(entry);
		}
	}
	
	return result;
}

sourceTimestampEntry *sourceTimestampTable_insertmulti_internal(sourceTimestampTable *table, const sourceTimestampEntry *entry, u64 hashValue)
{
	u32 chainIndex = hashValue % table->count;
	sourceTimestampChain *chain = table->data + chainIndex;
	sourceTimestampEntry *result = bba_add_noclear(*chain, 1);
	if(result != NULL) {
		*result = sourceTimestampEntry_clone(entry);
	}
	
	return result;
}

sourceTimestampEntry *sourceTimestampTable_find(sourceTimestampTable *table, const char *name)
{
	if(!name) {
		name = "";
	}
	sourceTimestampEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = sourceTimestampEntry_hash(&entry);
	return sourceTimestampTable_find_internal(table, &entry, hashValue);
}

sourceTimestampEntry *sourceTimestampTable_insert(sourceTimestampTable *table, const sourceTimestampEntry *entry)
{
	u64 hashValue = sourceTimestampEntry_hash(entry);
	return sourceTimestampTable_insert_internal(table, entry, hashValue);
}

sourceTimestampEntry *sourceTimestampTable_insertmulti(sourceTimestampTable *table, const sourceTimestampEntry *entry)
{
	u64 hashValue = sourceTimestampEntry_hash(entry);
	return sourceTimestampTable_insertmulti_internal(table, entry, hashValue);
}

void sourceTimestampTable_remove(sourceTimestampTable *table, const char *name)
{
	sourceTimestampEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = sourceTimestampEntry_hash(&entry);

	u32 chainIndex = hashValue % table->count;
	sourceTimestampChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count; ++i) {
		sourceTimestampEntry *existing = chain->data + i;
		if(!sourceTimestampEntry_compare(existing, &entry)) {
			sourceTimestampEntry_reset(existing);
			bba_erase(*chain, i);
			return;
		}
	}
}

void sourceTimestampTable_removemulti(sourceTimestampTable *table, const char *name)
{
	sourceTimestampEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = sourceTimestampEntry_hash(&entry);

	u32 chainIndex = hashValue % table->count;
	sourceTimestampChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count;) {
		sourceTimestampEntry *existing = chain->data + i;
		if(sourceTimestampEntry_compare(existing, &entry)) {
			++i;
		} else {
			sourceTimestampEntry_reset(existing);
			bba_erase(*chain, i);
		}
	}
}

u64 buildDependencyEntry_hash(const buildDependencyEntry *entry)
{
	return strsimplehash(sb_get(&entry->key));
}

int buildDependencyEntry_compare(const buildDependencyEntry *a, const buildDependencyEntry *b)
{
	return strcmp(sb_get(&a->key), sb_get(&b->key));
}

buildDependencyEntry *buildDependencyTable_find_internal(buildDependencyTable *table, const buildDependencyEntry *entry, u64 hashValue)
{
	BB_ASSERT_MSG(table->count, "need to initialize hash table count");
	u32 chainIndex = hashValue % table->count;
	buildDependencyChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count; ++i) {
		buildDependencyEntry *existing = chain->data + i;
		if(!buildDependencyEntry_compare(existing, entry)) {
			return existing;
		}
	}
	return NULL;
}

buildDependencyEntry *buildDependencyTable_insert_internal(buildDependencyTable *table, const buildDependencyEntry *entry, u64 hashValue)
{
	BB_ASSERT_MSG(table->count, "need to initialize hash table count");
	buildDependencyEntry *result = buildDependencyTable_find_internal(table, entry, hashValue);
	if(!result) {
		u32 chainIndex = hashValue % table->count;
		buildDependencyChain *chain = table->data + chainIndex;
		result = bba_add_noclear(*chain, 1);
		if(result != NULL) {
			*result = buildDependencyEntry_clone(entry);
		}
	}
	
	return result;
}

buildDependencyEntry *buildDependencyTable_insertmulti_internal(buildDependencyTable *table, const buildDependencyEntry *entry, u64 hashValue)
{
	u32 chainIndex = hashValue % table->count;
	buildDependencyChain *chain = table->data + chainIndex;
	buildDependencyEntry *result = bba_add_noclear(*chain, 1);
	if(result != NULL) {
		*result = buildDependencyEntry_clone(entry);
	}
	
	return result;
}

buildDependencyEntry *buildDependencyTable_find(buildDependencyTable *table, const char *name)
{
	if(!name) {
		name = "";
	}
	buildDependencyEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = buildDependencyEntry_hash(&entry);
	return buildDependencyTable_find_internal(table, &entry, hashValue);
}

buildDependencyEntry *buildDependencyTable_insert(buildDependencyTable *table, const buildDependencyEntry *entry)
{
	u64 hashValue = buildDependencyEntry_hash(entry);
	return buildDependencyTable_insert_internal(table, entry, hashValue);
}

buildDependencyEntry *buildDependencyTable_insertmulti(buildDependencyTable *table, const buildDependencyEntry *entry)
{
	u64 hashValue = buildDependencyEntry_hash(entry);
	return buildDependencyTable_insertmulti_internal(table, entry, hashValue);
}

void buildDependencyTable_remove(buildDependencyTable *table, const char *name)
{
	buildDependencyEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = buildDependencyEntry_hash(&entry);

	u32 chainIndex = hashValue % table->count;
	buildDependencyChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count; ++i) {
		buildDependencyEntry *existing = chain->data + i;
		if(!buildDependencyEntry_compare(existing, &entry)) {
			buildDependencyEntry_reset(existing);
			bba_erase(*chain, i);
			return;
		}
	}
}

void buildDependencyTable_removemulti(buildDependencyTable *table, const char *name)
{
	buildDependencyEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = buildDependencyEntry_hash(&entry);

	u32 chainIndex = hashValue % table->count;
	buildDependencyChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count;) {
		buildDependencyEntry *existing = chain->data + i;
		if(buildDependencyEntry_compare(existing, &entry)) {
			++i;
		} else {
			buildDependencyEntry_reset(existing);
			bba_erase(*chain, i);
		}
	}
}
