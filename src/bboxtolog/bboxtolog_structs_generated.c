// Copyright (c) 2012-2023 Matt Campbell
// MIT license (see License.txt)

// AUTOGENERATED FILE - DO NOT EDIT

// clang-format off

#include "bboxtolog_structs_generated.h"
#include "bb_assert.h"
#include "bb_array.h"
#include "str.h"
#include "va.h"

#include "sb.h"
#include "sdict.h"
#include "uuid_rfc4122/sysdep.h"
#include "view_filter.h"

#include <string.h>


void vfilter_token_reset(vfilter_token_t *val)
{
	if(val) {
	}
}
vfilter_token_t vfilter_token_clone(const vfilter_token_t *src)
{
	vfilter_token_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.span = src->span;
		dst.type = src->type;
		dst.number = src->number;
	}
	return dst;
}

void vfilter_tokens_reset(vfilter_tokens_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			vfilter_token_reset(val->data + i);
		}
		bba_free(*val);
	}
}
vfilter_tokens_t vfilter_tokens_clone(const vfilter_tokens_t *src)
{
	vfilter_tokens_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = vfilter_token_clone(src->data + i);
			}
		}
	}
	return dst;
}

void vfilter_error_reset(vfilter_error_t *val)
{
	if(val) {
		sb_reset(&val->text);
	}
}
vfilter_error_t vfilter_error_clone(const vfilter_error_t *src)
{
	vfilter_error_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.text = sb_clone(&src->text);
		dst.column = src->column;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void vfilter_result_reset(vfilter_result_t *val)
{
	if(val) {
	}
}
vfilter_result_t vfilter_result_clone(const vfilter_result_t *src)
{
	vfilter_result_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.value = src->value;
	}
	return dst;
}

void vfilter_results_reset(vfilter_results_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			vfilter_result_reset(val->data + i);
		}
		bba_free(*val);
	}
}
vfilter_results_t vfilter_results_clone(const vfilter_results_t *src)
{
	vfilter_results_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = vfilter_result_clone(src->data + i);
			}
		}
	}
	return dst;
}

void named_vfilters_reset(named_vfilters_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			vfilter_reset(val->data + i);
		}
		bba_free(*val);
	}
}
named_vfilters_t named_vfilters_clone(const named_vfilters_t *src)
{
	named_vfilters_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = vfilter_clone(src->data + i);
			}
		}
	}
	return dst;
}

void vfilter_reset(vfilter_t *val)
{
	if(val) {
		sb_reset(&val->name);
		sb_reset(&val->input);
		sb_reset(&val->tokenstream);
		vfilter_tokens_reset(&val->tokens);
		vfilter_tokens_reset(&val->rpn_tokens);
		vfilter_error_reset(&val->error);
		vfilter_results_reset(&val->results);
	}
}
vfilter_t vfilter_clone(const vfilter_t *src)
{
	vfilter_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.name = sb_clone(&src->name);
		dst.input = sb_clone(&src->input);
		dst.tokenstream = sb_clone(&src->tokenstream);
		dst.tokens = vfilter_tokens_clone(&src->tokens);
		dst.rpn_tokens = vfilter_tokens_clone(&src->rpn_tokens);
		dst.error = vfilter_error_clone(&src->error);
		dst.results = vfilter_results_clone(&src->results);
		dst.type = src->type;
		dst.valid = src->valid;
	}
	return dst;
}
