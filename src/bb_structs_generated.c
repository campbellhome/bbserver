// Copyright (c) 2012-2019 Matt Campbell
// MIT license (see License.txt)

// AUTOGENERATED FILE - DO NOT EDIT

// clang-format off

#include "bb_structs_generated.h"
#include "bb_array.h"
#include "str.h"
#include "va.h"

#include "config.h"
#include "device_codes.h"
#include "fonts.h"
#include "message_queue.h"
#include "recordings.h"
#include "sb.h"
#include "sdict.h"
#include "site_config.h"
#include "tags.h"
#include "theme_config.h"
#include "uuid_config.h"
#include "uuid_rfc4122/sysdep.h"
#include "view.h"
#include "view_filter.h"

#include <string.h>


void POINT_reset(POINT *val)
{
	if(val) {
	}
}
POINT POINT_clone(const POINT *src)
{
	POINT dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.x = src->x;
		dst.y = src->y;
	}
	return dst;
}

void RECT_reset(RECT *val)
{
	if(val) {
	}
}
RECT RECT_clone(const RECT *src)
{
	RECT dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.left = src->left;
		dst.top = src->top;
		dst.right = src->right;
		dst.bottom = src->bottom;
	}
	return dst;
}

void WINDOWPLACEMENT_reset(WINDOWPLACEMENT *val)
{
	if(val) {
		POINT_reset(&val->ptMinPosition);
		POINT_reset(&val->ptMaxPosition);
		RECT_reset(&val->rcNormalPosition);
	}
}
WINDOWPLACEMENT WINDOWPLACEMENT_clone(const WINDOWPLACEMENT *src)
{
	WINDOWPLACEMENT dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.length = src->length;
		dst.flags = src->flags;
		dst.showCmd = src->showCmd;
		dst.ptMinPosition = POINT_clone(&src->ptMinPosition);
		dst.ptMaxPosition = POINT_clone(&src->ptMaxPosition);
		dst.rcNormalPosition = RECT_clone(&src->rcNormalPosition);
	}
	return dst;
}

void configWhitelistEntry_reset(configWhitelistEntry_t *val)
{
	if(val) {
		sb_reset(&val->addressPlusMask);
		sb_reset(&val->applicationName);
		sb_reset(&val->comment);
	}
}
configWhitelistEntry_t configWhitelistEntry_clone(const configWhitelistEntry_t *src)
{
	configWhitelistEntry_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.allow = src->allow;
		dst.autodetectedDevkit = src->autodetectedDevkit;
		dst.delay = src->delay;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
		dst.addressPlusMask = sb_clone(&src->addressPlusMask);
		dst.applicationName = sb_clone(&src->applicationName);
		dst.comment = sb_clone(&src->comment);
	}
	return dst;
}

void configWhitelist_reset(configWhitelist_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			configWhitelistEntry_reset(val->data + i);
		}
		bba_free(*val);
	}
}
configWhitelist_t configWhitelist_clone(const configWhitelist_t *src)
{
	configWhitelist_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = configWhitelistEntry_clone(src->data + i);
			}
		}
	}
	return dst;
}

void openTargetEntry_reset(openTargetEntry_t *val)
{
	if(val) {
		sb_reset(&val->displayName);
		sb_reset(&val->commandLine);
	}
}
openTargetEntry_t openTargetEntry_clone(const openTargetEntry_t *src)
{
	openTargetEntry_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.displayName = sb_clone(&src->displayName);
		dst.commandLine = sb_clone(&src->commandLine);
	}
	return dst;
}

void openTargetList_reset(openTargetList_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			openTargetEntry_reset(val->data + i);
		}
		bba_free(*val);
	}
}
openTargetList_t openTargetList_clone(const openTargetList_t *src)
{
	openTargetList_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = openTargetEntry_clone(src->data + i);
			}
		}
	}
	return dst;
}

void pathFixupEntry_reset(pathFixupEntry_t *val)
{
	if(val) {
		sb_reset(&val->src);
		sb_reset(&val->dst);
	}
}
pathFixupEntry_t pathFixupEntry_clone(const pathFixupEntry_t *src)
{
	pathFixupEntry_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.src = sb_clone(&src->src);
		dst.dst = sb_clone(&src->dst);
	}
	return dst;
}

void pathFixupList_reset(pathFixupList_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			pathFixupEntry_reset(val->data + i);
		}
		bba_free(*val);
	}
}
pathFixupList_t pathFixupList_clone(const pathFixupList_t *src)
{
	pathFixupList_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = pathFixupEntry_clone(src->data + i);
			}
		}
	}
	return dst;
}

void tooltipConfig_reset(tooltipConfig *val)
{
	if(val) {
	}
}
tooltipConfig tooltipConfig_clone(const tooltipConfig *src)
{
	tooltipConfig dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.enabled = src->enabled;
		dst.overText = src->overText;
		dst.overMisc = src->overMisc;
		dst.onlyOverSelected = src->onlyOverSelected;
		dst.delay = src->delay;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void sizeConfig_reset(sizeConfig *val)
{
	if(val) {
	}
}
sizeConfig sizeConfig_clone(const sizeConfig *src)
{
	sizeConfig dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.resizeBarSize = src->resizeBarSize;
		dst.scrollbarSize = src->scrollbarSize;
	}
	return dst;
}

void config_reset(config_t *val)
{
	if(val) {
		configWhitelist_reset(&val->whitelist);
		openTargetList_reset(&val->openTargets);
		pathFixupList_reset(&val->pathFixups);
		fontConfig_reset(&val->logFontConfig);
		fontConfig_reset(&val->uiFontConfig);
		sb_reset(&val->colorscheme);
		WINDOWPLACEMENT_reset(&val->wp);
		tooltipConfig_reset(&val->tooltips);
		sizeConfig_reset(&val->sizes);
	}
}
config_t config_clone(const config_t *src)
{
	config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.whitelist = configWhitelist_clone(&src->whitelist);
		dst.openTargets = openTargetList_clone(&src->openTargets);
		dst.pathFixups = pathFixupList_clone(&src->pathFixups);
		dst.logFontConfig = fontConfig_clone(&src->logFontConfig);
		dst.uiFontConfig = fontConfig_clone(&src->uiFontConfig);
		dst.colorscheme = sb_clone(&src->colorscheme);
		dst.wp = WINDOWPLACEMENT_clone(&src->wp);
		dst.version = src->version;
		dst.viewTileMode = src->viewTileMode;
		dst.alternateRowBackground = src->alternateRowBackground;
		dst.textShadows = src->textShadows;
		dst.logColorUsage = src->logColorUsage;
		dst.tooltips = tooltipConfig_clone(&src->tooltips);
		dst.sizes = sizeConfig_clone(&src->sizes);
		dst.dpiAware = src->dpiAware;
		dst.dpiScrollwheel = src->dpiScrollwheel;
		dst.autoDeleteAfterDays = src->autoDeleteAfterDays;
		dst.autoCloseAll = src->autoCloseAll;
		dst.autoCloseManual = src->autoCloseManual;
		dst.updateManagement = src->updateManagement;
		dst.doubleClickSeconds = src->doubleClickSeconds;
		dst.dpiScale = src->dpiScale;
		dst.updateWaitForDebugger = src->updateWaitForDebugger;
		dst.updatePauseAfterSuccessfulUpdate = src->updatePauseAfterSuccessfulUpdate;
		dst.updatePauseAfterFailedUpdate = src->updatePauseAfterFailedUpdate;
		dst.assertMessageBox = src->assertMessageBox;
		dst.showDebugMenu = src->showDebugMenu;
		dst.showEmptyCategories = src->showEmptyCategories;
	}
	return dst;
}

void deviceCodes_reset(deviceCodes_t *val)
{
	if(val) {
		sbs_reset(&val->deviceCodes);
	}
}
deviceCodes_t deviceCodes_clone(const deviceCodes_t *src)
{
	deviceCodes_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.deviceCodes = sbs_clone(&src->deviceCodes);
	}
	return dst;
}

void message_queue_message_reset(message_queue_message_t *val)
{
	if(val) {
	}
}
message_queue_message_t message_queue_message_clone(const message_queue_message_t *src)
{
	message_queue_message_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.command = src->command;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->text); ++i) {
			dst.text[i] = src->text[i];
		}
	}
	return dst;
}

void message_queue_messages_reset(message_queue_messages_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			message_queue_message_reset(val->data + i);
		}
		bba_free(*val);
	}
}
message_queue_messages_t message_queue_messages_clone(const message_queue_messages_t *src)
{
	message_queue_messages_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = message_queue_message_clone(src->data + i);
			}
		}
	}
	return dst;
}

void FILETIME_reset(FILETIME *val)
{
	if(val) {
	}
}
FILETIME FILETIME_clone(const FILETIME *src)
{
	FILETIME dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.dwLowDateTime = src->dwLowDateTime;
		dst.dwHighDateTime = src->dwHighDateTime;
	}
	return dst;
}

void new_recording_reset(new_recording_t *val)
{
	if(val) {
		sb_reset(&val->applicationName);
		sb_reset(&val->applicationFilename);
		sb_reset(&val->path);
		FILETIME_reset(&val->filetime);
	}
}
new_recording_t new_recording_clone(const new_recording_t *src)
{
	new_recording_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.applicationName = sb_clone(&src->applicationName);
		dst.applicationFilename = sb_clone(&src->applicationFilename);
		dst.path = sb_clone(&src->path);
		dst.filetime = FILETIME_clone(&src->filetime);
		dst.openView = src->openView;
		dst.recordingType = src->recordingType;
		dst.mqId = src->mqId;
		dst.platform = src->platform;
	}
	return dst;
}

void recordings_tab_config_reset(recordings_tab_config_t *val)
{
	if(val) {
	}
}
recordings_tab_config_t recordings_tab_config_clone(const recordings_tab_config_t *src)
{
	recordings_tab_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.group = src->group;
		dst.sort = src->sort;
		dst.showDate = src->showDate;
		dst.showTime = src->showTime;
		dst.showInternal = src->showInternal;
		dst.showExternal = src->showExternal;
	}
	return dst;
}

void recordings_config_reset(recordings_config_t *val)
{
	if(val) {
		for(u32 i = 0; i < BB_ARRAYSIZE(val->tabs); ++i) {
			recordings_tab_config_reset(val->tabs + i);
		}
	}
}
recordings_config_t recordings_config_clone(const recordings_config_t *src)
{
	recordings_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < BB_ARRAYSIZE(src->tabs); ++i) {
			dst.tabs[i] = recordings_tab_config_clone(&src->tabs[i]);
		}
		dst.width = src->width;
		dst.recordingsOpen = src->recordingsOpen;
	}
	return dst;
}

void updateConfig_reset(updateConfig_t *val)
{
	if(val) {
		sb_reset(&val->updateResultDir);
		sb_reset(&val->updateAvailableMessage);
		sb_reset(&val->updateIgnoredMessage);
		sb_reset(&val->updateShutdownMessage);
		sb_reset(&val->updateManifestDir);
	}
}
updateConfig_t updateConfig_clone(const updateConfig_t *src)
{
	updateConfig_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.updateResultDir = sb_clone(&src->updateResultDir);
		dst.updateAvailableMessage = sb_clone(&src->updateAvailableMessage);
		dst.updateIgnoredMessage = sb_clone(&src->updateIgnoredMessage);
		dst.updateShutdownMessage = sb_clone(&src->updateShutdownMessage);
		dst.updateManifestDir = sb_clone(&src->updateManifestDir);
		dst.updateCheckMs = src->updateCheckMs;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void site_config_reset(site_config_t *val)
{
	if(val) {
		updateConfig_reset(&val->updates);
		sb_reset(&val->bugAssignee);
		sb_reset(&val->bugProject);
	}
}
site_config_t site_config_clone(const site_config_t *src)
{
	site_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.updates = updateConfig_clone(&src->updates);
		dst.bugAssignee = sb_clone(&src->bugAssignee);
		dst.bugProject = sb_clone(&src->bugProject);
		dst.autodetectDevkits = src->autodetectDevkits;
		dst.bugPort = src->bugPort;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void sbsHashEntry_reset_from_loc(const char *file, int line, sbsHashEntry *val)
{
	if(val) {
		sb_reset_from_loc(file, line, &val->key);
		sbs_reset_from_loc(file, line, &val->values);
	}
}
sbsHashEntry sbsHashEntry_clone_from_loc(const char *file, int line, const sbsHashEntry *src)
{
	sbsHashEntry dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.key = sb_clone_from_loc(file, line, &src->key);
		dst.values = sbs_clone_from_loc(file, line, &src->values);
	}
	return dst;
}

void tag_reset_from_loc(const char *file, int line, tag_t *val)
{
	if(val) {
		sb_reset_from_loc(file, line, &val->name);
		sbs_reset_from_loc(file, line, &val->categories);
	}
}
tag_t tag_clone_from_loc(const char *file, int line, const tag_t *src)
{
	tag_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.name = sb_clone_from_loc(file, line, &src->name);
		dst.categories = sbs_clone_from_loc(file, line, &src->categories);
		dst.visibility = src->visibility;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void tags_reset_from_loc(const char *file, int line, tags_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			tag_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
tags_t tags_clone_from_loc(const char *file, int line, const tags_t *src)
{
	tags_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = tag_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void tags_config_reset(tags_config_t *val)
{
	if(val) {
		tags_reset(&val->tags);
	}
}
tags_config_t tags_config_clone(const tags_config_t *src)
{
	tags_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.tags = tags_clone(&src->tags);
	}
	return dst;
}

void sbsHashChain_reset_from_loc(const char *file, int line, sbsHashChain *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			sbsHashEntry_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
sbsHashChain sbsHashChain_clone_from_loc(const char *file, int line, const sbsHashChain *src)
{
	sbsHashChain dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = sbsHashEntry_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void sbsHashTable_reset_from_loc(const char *file, int line, sbsHashTable *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			sbsHashChain_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
sbsHashTable sbsHashTable_clone_from_loc(const char *file, int line, const sbsHashTable *src)
{
	sbsHashTable dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = sbsHashChain_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void tagCategory_reset_from_loc(const char *file, int line, tagCategory_t *val)
{
	if(val) {
		sb_reset_from_loc(file, line, &val->name);
		sbs_reset_from_loc(file, line, &val->tags);
	}
}
tagCategory_t tagCategory_clone_from_loc(const char *file, int line, const tagCategory_t *src)
{
	tagCategory_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.name = sb_clone_from_loc(file, line, &src->name);
		dst.tags = sbs_clone_from_loc(file, line, &src->tags);
	}
	return dst;
}

void tagCategories_reset_from_loc(const char *file, int line, tagCategories_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			tagCategory_reset_from_loc(file, line, val->data + i);
		}
		bba_free(*val);
	}
}
tagCategories_t tagCategories_clone_from_loc(const char *file, int line, const tagCategories_t *src)
{
	tagCategories_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = tagCategory_clone_from_loc(file, line, src->data + i);
			}
		}
	}
	return dst;
}

void tagData_reset(tagData_t *val)
{
	if(val) {
		sbsHashTable_reset(&val->tagTable);
		sbsHashTable_reset(&val->categoryTable);
		tags_reset(&val->tags);
		tagCategories_reset(&val->categories);
	}
}
tagData_t tagData_clone(const tagData_t *src)
{
	tagData_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.tagTable = sbsHashTable_clone(&src->tagTable);
		dst.categoryTable = sbsHashTable_clone(&src->categoryTable);
		dst.tags = tags_clone(&src->tags);
		dst.categories = tagCategories_clone(&src->categories);
	}
	return dst;
}

void color_config_reset(color_config_t *val)
{
	if(val) {
	}
}
color_config_t color_config_clone(const color_config_t *src)
{
	color_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.colorName = src->colorName;
		dst.r = src->r;
		dst.g = src->g;
		dst.b = src->b;
		dst.a = src->a;
		dst.bTextShadows = src->bTextShadows;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void colors_config_reset(colors_config_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			color_config_reset(val->data + i);
		}
		bba_free(*val);
	}
}
colors_config_t colors_config_clone(const colors_config_t *src)
{
	colors_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = color_config_clone(src->data + i);
			}
		}
	}
	return dst;
}

void theme_config_reset(theme_config_t *val)
{
	if(val) {
		colors_config_reset(&val->colors);
	}
}
theme_config_t theme_config_clone(const theme_config_t *src)
{
	theme_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.colors = colors_config_clone(&src->colors);
	}
	return dst;
}

void uuidState_reset(uuidState_t *val)
{
	if(val) {
		uuid_node_reset(&val->nodeId);
	}
}
uuidState_t uuidState_clone(const uuidState_t *src)
{
	uuidState_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.timestampLow = src->timestampLow;
		dst.timestampHi = src->timestampHi;
		dst.clockSequence = src->clockSequence;
		dst.nodeId = uuid_node_clone(&src->nodeId);
	}
	return dst;
}

void view_pieInstance_reset(view_pieInstance_t *val)
{
	if(val) {
	}
}
view_pieInstance_t view_pieInstance_clone(const view_pieInstance_t *src)
{
	view_pieInstance_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.selected = src->selected;
		dst.visible = src->visible;
		dst.pieInstance = src->pieInstance;
		dst.primary = src->primary;
	}
	return dst;
}

void view_pieInstances_reset(view_pieInstances_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_pieInstance_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_pieInstances_t view_pieInstances_clone(const view_pieInstances_t *src)
{
	view_pieInstances_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_pieInstance_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_config_thread_reset(view_config_thread_t *val)
{
	if(val) {
		sb_reset(&val->name);
	}
}
view_config_thread_t view_config_thread_clone(const view_config_thread_t *src)
{
	view_config_thread_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.name = sb_clone(&src->name);
		dst.selected = src->selected;
		dst.visible = src->visible;
	}
	return dst;
}

void view_config_threads_reset(view_config_threads_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_config_thread_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_config_threads_t view_config_threads_clone(const view_config_threads_t *src)
{
	view_config_threads_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_config_thread_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_config_file_reset(view_config_file_t *val)
{
	if(val) {
		sb_reset(&val->path);
	}
}
view_config_file_t view_config_file_clone(const view_config_file_t *src)
{
	view_config_file_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.path = sb_clone(&src->path);
		dst.selected = src->selected;
		dst.visible = src->visible;
	}
	return dst;
}

void view_config_files_reset(view_config_files_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_config_file_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_config_files_t view_config_files_clone(const view_config_files_t *src)
{
	view_config_files_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_config_file_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_config_category_reset(view_config_category_t *val)
{
	if(val) {
		sb_reset(&val->name);
	}
}
view_config_category_t view_config_category_clone(const view_config_category_t *src)
{
	view_config_category_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.name = sb_clone(&src->name);
		dst.selected = src->selected;
		dst.visible = src->visible;
		dst.depth = src->depth;
		dst.disabled = src->disabled;
	}
	return dst;
}

void view_config_categories_reset(view_config_categories_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_config_category_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_config_categories_t view_config_categories_clone(const view_config_categories_t *src)
{
	view_config_categories_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_config_category_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_config_column_reset(view_config_column_t *val)
{
	if(val) {
		sb_reset(&val->name);
	}
}
view_config_column_t view_config_column_clone(const view_config_column_t *src)
{
	view_config_column_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.name = sb_clone(&src->name);
		dst.visible = src->visible;
		dst.width = src->width;
	}
	return dst;
}

void view_config_columns_reset(view_config_columns_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_config_column_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_config_columns_t view_config_columns_clone(const view_config_columns_t *src)
{
	view_config_columns_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_config_column_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_console_history_entry_reset(view_console_history_entry_t *val)
{
	if(val) {
		sb_reset(&val->command);
	}
}
view_console_history_entry_t view_console_history_entry_clone(const view_console_history_entry_t *src)
{
	view_console_history_entry_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.command = sb_clone(&src->command);
	}
	return dst;
}

void view_console_history_entries_reset(view_console_history_entries_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_console_history_entry_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_console_history_entries_t view_console_history_entries_clone(const view_console_history_entries_t *src)
{
	view_console_history_entries_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_console_history_entry_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_console_history_reset(view_console_history_t *val)
{
	if(val) {
		view_console_history_entries_reset(&val->entries);
	}
}
view_console_history_t view_console_history_clone(const view_console_history_t *src)
{
	view_console_history_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.entries = view_console_history_entries_clone(&src->entries);
		dst.pos = src->pos;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void view_config_reset(view_config_t *val)
{
	if(val) {
		view_config_columns_reset(&val->configColumns);
		view_config_threads_reset(&val->configThreads);
		view_config_files_reset(&val->configFiles);
		view_config_categories_reset(&val->configCategories);
		view_console_history_reset(&val->consoleHistory);
		view_console_history_reset(&val->filterHistory);
		sb_reset(&val->filterInput);
		sb_reset(&val->spansInput);
	}
}
view_config_t view_config_clone(const view_config_t *src)
{
	view_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.configColumns = view_config_columns_clone(&src->configColumns);
		dst.configThreads = view_config_threads_clone(&src->configThreads);
		dst.configFiles = view_config_files_clone(&src->configFiles);
		dst.configCategories = view_config_categories_clone(&src->configCategories);
		dst.consoleHistory = view_console_history_clone(&src->consoleHistory);
		dst.filterHistory = view_console_history_clone(&src->filterHistory);
		dst.filterInput = sb_clone(&src->filterInput);
		dst.spansInput = sb_clone(&src->spansInput);
		dst.showVeryVerbose = src->showVeryVerbose;
		dst.showVerbose = src->showVerbose;
		dst.showLogs = src->showLogs;
		dst.showDisplay = src->showDisplay;
		dst.showWarnings = src->showWarnings;
		dst.showErrors = src->showErrors;
		dst.showFatal = src->showFatal;
		dst.showSelectorTarget = src->showSelectorTarget;
		dst.newNonFavoriteCategoryVisibility = src->newNonFavoriteCategoryVisibility;
		dst.newThreadVisibility = src->newThreadVisibility;
		dst.newFileVisibility = src->newFileVisibility;
		dst.filterActive = src->filterActive;
		dst.showFilterHelp = src->showFilterHelp;
		dst.version = src->version;
	}
	return dst;
}

void view_config_log_reset(view_config_log_t *val)
{
	if(val) {
	}
}
view_config_log_t view_config_log_clone(const view_config_log_t *src)
{
	view_config_log_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.sessionLogIndex = src->sessionLogIndex;
		dst.subLine = src->subLine;
		dst.bookmarked = src->bookmarked;
		dst.selected = src->selected;
	}
	return dst;
}

void view_config_logs_reset(view_config_logs_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_config_log_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_config_logs_t view_config_logs_clone(const view_config_logs_t *src)
{
	view_config_logs_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_config_log_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_config_log_index_reset(view_config_log_index_t *val)
{
	if(val) {
	}
}
view_config_log_index_t view_config_log_index_clone(const view_config_log_index_t *src)
{
	view_config_log_index_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.sessionLogIndex = src->sessionLogIndex;
		dst.subLine = src->subLine;
	}
	return dst;
}

void view_config_log_indices_reset(view_config_log_indices_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			view_config_log_index_reset(val->data + i);
		}
		bba_free(*val);
	}
}
view_config_log_indices_t view_config_log_indices_clone(const view_config_log_indices_t *src)
{
	view_config_log_indices_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = view_config_log_index_clone(src->data + i);
			}
		}
	}
	return dst;
}

void view_session_config_reset(view_session_config_t *val)
{
	if(val) {
		view_config_reset(&val->viewConfig);
		view_config_log_indices_reset(&val->selectedLogs);
		view_config_log_indices_reset(&val->bookmarkedLogs);
	}
}
view_session_config_t view_session_config_clone(const view_session_config_t *src)
{
	view_session_config_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.viewConfig = view_config_clone(&src->viewConfig);
		dst.selectedLogs = view_config_log_indices_clone(&src->selectedLogs);
		dst.bookmarkedLogs = view_config_log_indices_clone(&src->bookmarkedLogs);
		dst.version = src->version;
		dst.pad = src->pad;
	}
	return dst;
}

void vfilter_token_reset(vfilter_token_t *val)
{
	if(val) {
	}
}
vfilter_token_t vfilter_token_clone(const vfilter_token_t *src)
{
	vfilter_token_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.span = src->span;
		dst.type = src->type;
		dst.number = src->number;
	}
	return dst;
}

void vfilter_tokens_reset(vfilter_tokens_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			vfilter_token_reset(val->data + i);
		}
		bba_free(*val);
	}
}
vfilter_tokens_t vfilter_tokens_clone(const vfilter_tokens_t *src)
{
	vfilter_tokens_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = vfilter_token_clone(src->data + i);
			}
		}
	}
	return dst;
}

void vfilter_error_reset(vfilter_error_t *val)
{
	if(val) {
		sb_reset(&val->text);
	}
}
vfilter_error_t vfilter_error_clone(const vfilter_error_t *src)
{
	vfilter_error_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.text = sb_clone(&src->text);
		dst.column = src->column;
		for(u32 i = 0; i < BB_ARRAYSIZE(src->pad); ++i) {
			dst.pad[i] = src->pad[i];
		}
	}
	return dst;
}

void vfilter_result_reset(vfilter_result_t *val)
{
	if(val) {
	}
}
vfilter_result_t vfilter_result_clone(const vfilter_result_t *src)
{
	vfilter_result_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.value = src->value;
	}
	return dst;
}

void vfilter_results_reset(vfilter_results_t *val)
{
	if(val) {
		for(u32 i = 0; i < val->count; ++i) {
			vfilter_result_reset(val->data + i);
		}
		bba_free(*val);
	}
}
vfilter_results_t vfilter_results_clone(const vfilter_results_t *src)
{
	vfilter_results_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		for(u32 i = 0; i < src->count; ++i) {
			if(bba_add_noclear(dst, 1)) {
				bba_last(dst) = vfilter_result_clone(src->data + i);
			}
		}
	}
	return dst;
}

void vfilter_reset(vfilter_t *val)
{
	if(val) {
		sb_reset(&val->input);
		sb_reset(&val->tokenstream);
		vfilter_tokens_reset(&val->tokens);
		vfilter_tokens_reset(&val->rpn_tokens);
		vfilter_error_reset(&val->error);
		vfilter_results_reset(&val->results);
	}
}
vfilter_t vfilter_clone(const vfilter_t *src)
{
	vfilter_t dst = { BB_EMPTY_INITIALIZER };
	if(src) {
		dst.input = sb_clone(&src->input);
		dst.tokenstream = sb_clone(&src->tokenstream);
		dst.tokens = vfilter_tokens_clone(&src->tokens);
		dst.rpn_tokens = vfilter_tokens_clone(&src->rpn_tokens);
		dst.error = vfilter_error_clone(&src->error);
		dst.results = vfilter_results_clone(&src->results);
		dst.type = src->type;
		dst.valid = src->valid;
	}
	return dst;
}

u64 sbsHashEntry_hash(const sbsHashEntry *entry)
{
	return strsimplehash(sb_get(&entry->key));
}

int sbsHashEntry_compare(const sbsHashEntry *a, const sbsHashEntry *b)
{
	return strcmp(sb_get(&a->key), sb_get(&b->key));
}

sbsHashEntry *sbsHashTable_find_internal(sbsHashTable *table, const sbsHashEntry *entry, u64 hashValue)
{
	BB_ASSERT_MSG(table->count, "need to initialize hash table count");
	u32 chainIndex = hashValue % table->count;
	sbsHashChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count; ++i) {
		sbsHashEntry *existing = chain->data + i;
		if(!sbsHashEntry_compare(existing, entry)) {
			return existing;
		}
	}
	return NULL;
}

sbsHashEntry *sbsHashTable_insert_internal(sbsHashTable *table, const sbsHashEntry *entry, u64 hashValue)
{
	BB_ASSERT_MSG(table->count, "need to initialize hash table count");
	sbsHashEntry *result = sbsHashTable_find_internal(table, entry, hashValue);
	if(!result) {
		u32 chainIndex = hashValue % table->count;
		sbsHashChain *chain = table->data + chainIndex;
		result = bba_add_noclear(*chain, 1);
		if(result != NULL) {
			*result = sbsHashEntry_clone(entry);
		}
	}
	
	return result;
}

sbsHashEntry *sbsHashTable_insertmulti_internal(sbsHashTable *table, const sbsHashEntry *entry, u64 hashValue)
{
	u32 chainIndex = hashValue % table->count;
	sbsHashChain *chain = table->data + chainIndex;
	sbsHashEntry *result = bba_add_noclear(*chain, 1);
	if(result != NULL) {
		*result = sbsHashEntry_clone(entry);
	}
	
	return result;
}

sbsHashEntry *sbsHashTable_find(sbsHashTable *table, const char *name)
{
	if(!name) {
		name = "";
	}
	sbsHashEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = sbsHashEntry_hash(&entry);
	return sbsHashTable_find_internal(table, &entry, hashValue);
}

sbsHashEntry *sbsHashTable_insert(sbsHashTable *table, const sbsHashEntry *entry)
{
	u64 hashValue = sbsHashEntry_hash(entry);
	return sbsHashTable_insert_internal(table, entry, hashValue);
}

sbsHashEntry *sbsHashTable_insertmulti(sbsHashTable *table, const sbsHashEntry *entry)
{
	u64 hashValue = sbsHashEntry_hash(entry);
	return sbsHashTable_insertmulti_internal(table, entry, hashValue);
}

void sbsHashTable_remove(sbsHashTable *table, const char *name)
{
	sbsHashEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = sbsHashEntry_hash(&entry);

	u32 chainIndex = hashValue % table->count;
	sbsHashChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count; ++i) {
		sbsHashEntry *existing = chain->data + i;
		if(!sbsHashEntry_compare(existing, &entry)) {
			sbsHashEntry_reset(existing);
			bba_erase(*chain, i);
			return;
		}
	}
}

void sbsHashTable_removemulti(sbsHashTable *table, const char *name)
{
	sbsHashEntry entry = { BB_EMPTY_INITIALIZER };
	entry.key = sb_from_c_string_no_alloc(name);
	u64 hashValue = sbsHashEntry_hash(&entry);

	u32 chainIndex = hashValue % table->count;
	sbsHashChain *chain = table->data + chainIndex;
	for(u32 i = 0; i < chain->count;) {
		sbsHashEntry *existing = chain->data + i;
		if(sbsHashEntry_compare(existing, &entry)) {
			++i;
		} else {
			sbsHashEntry_reset(existing);
			bba_erase(*chain, i);
		}
	}
}
